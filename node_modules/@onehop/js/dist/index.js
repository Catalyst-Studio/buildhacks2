/* Copyright 2022 Hop, Inc */
import {
  ID_PREFIXES,
  __export,
  asId,
  assertId,
  getIdPrefix,
  id,
  validateId,
  validateIdPrefix
} from "./chunk-AZRIUYYL.js";

// src/util/fetch.ts
import * as ponyfill from "cross-fetch";
var HAS_NATIVE_FETCH = typeof globalThis.fetch !== "undefined";
var fetch = HAS_NATIVE_FETCH ? globalThis.fetch : ponyfill.default;
var Headers2 = HAS_NATIVE_FETCH ? globalThis.Headers : ponyfill.Headers;
var Request2 = HAS_NATIVE_FETCH ? globalThis.Request : ponyfill.Request;
var Response2 = HAS_NATIVE_FETCH ? globalThis.Response : ponyfill.Response;

// src/util/constants.ts
var DEFAULT_BASE_URL = "https://api.hop.io";
var IS_BROWSER = typeof window !== "undefined";

// src/util/urls.ts
function lead(x) {
  return x.charCodeAt(0) === 47 ? x : "/" + x;
}
function isObjectEmpty(object) {
  for (const _ in object) {
    return false;
  }
  return true;
}
function join(a, b) {
  return a + lead(b);
}
function querystring(query) {
  const usefulQuery = Object.entries(query).filter(
    (entry) => {
      const [, value] = entry;
      return value !== void 0;
    }
  );
  if (usefulQuery.length === 0) {
    return "";
  }
  const INITIAL_QUERYSTRING = "?";
  return usefulQuery.reduce((acc, [key, value]) => {
    if (value === void 0) {
      return acc;
    }
    const result = `${key}=${value.toString()}`;
    if (acc === INITIAL_QUERYSTRING) {
      return INITIAL_QUERYSTRING + result;
    }
    return acc + "&" + result;
  }, INITIAL_QUERYSTRING);
}
function createURLBuilder(base) {
  const regex = /:[^/?#]+/g;
  return (path, query) => {
    query = { ...query };
    const urlWithParams = path.replace(regex, (param) => {
      param = param.substring(1);
      if (param in query) {
        const { [param]: value, ...rest } = query;
        query = rest;
        if (value === void 0) {
          throw new Error(`URL param ${param} is undefined`);
        }
        if (typeof value === "number") {
          return value.toString();
        }
        return value;
      }
      throw new Error(`Missing param ${param}.`);
    });
    const urlWithSearch = isObjectEmpty(query) ? urlWithParams : `${urlWithParams}${querystring(query)}`;
    return join(base, urlWithSearch);
  };
}

// src/rest/types/api.ts
var api_exports = {};
__export(api_exports, {
  Channels: () => channels_exports,
  Ignite: () => ignite_exports,
  Pipe: () => pipe_exports,
  Projects: () => projects_exports,
  Registry: () => registry_exports,
  Users: () => users_exports
});

// src/rest/types/channels.ts
var channels_exports = {};
__export(channels_exports, {
  ChannelType: () => ChannelType
});
var ChannelType = /* @__PURE__ */ ((ChannelType2) => {
  ChannelType2["PRIVATE"] = "private";
  ChannelType2["PUBLIC"] = "public";
  ChannelType2["UNPROTECTED"] = "unprotected";
  return ChannelType2;
})(ChannelType || {});

// src/rest/types/registry.ts
var registry_exports = {};

// src/rest/types/ignite.ts
var ignite_exports = {};
__export(ignite_exports, {
  ContainerState: () => ContainerState,
  DomainState: () => DomainState,
  GatewayType: () => GatewayType,
  Regions: () => Regions,
  RuntimeType: () => RuntimeType,
  VgpuType: () => VgpuType
});
var Regions = /* @__PURE__ */ ((Regions2) => {
  Regions2["US_EAST_1"] = "us-east-1";
  return Regions2;
})(Regions || {});
var RuntimeType = /* @__PURE__ */ ((RuntimeType2) => {
  RuntimeType2["EPHEMERAL"] = "ephemeral";
  RuntimeType2["PERSISTENT"] = "persistent";
  return RuntimeType2;
})(RuntimeType || {});
var ContainerState = /* @__PURE__ */ ((ContainerState2) => {
  ContainerState2["PENDING"] = "pending";
  ContainerState2["RUNNING"] = "running";
  ContainerState2["STOPPED"] = "stopped";
  ContainerState2["FAILED"] = "failed";
  ContainerState2["TERMINATING"] = "terminating";
  ContainerState2["EXITED"] = "exited";
  return ContainerState2;
})(ContainerState || {});
var VgpuType = /* @__PURE__ */ ((VgpuType2) => {
  VgpuType2["A400"] = "a400";
  return VgpuType2;
})(VgpuType || {});
var GatewayType = /* @__PURE__ */ ((GatewayType2) => {
  GatewayType2["INTERNAL"] = "internal";
  GatewayType2["EXTERNAL"] = "external";
  return GatewayType2;
})(GatewayType || {});
var DomainState = /* @__PURE__ */ ((DomainState2) => {
  DomainState2["PENDING"] = "pending";
  DomainState2["VALID_CNAME"] = "valid_cname";
  DomainState2["SSL_ACTIVE"] = "ssl_active";
  return DomainState2;
})(DomainState || {});

// src/rest/types/pipe.ts
var pipe_exports = {};

// src/rest/types/projects.ts
var projects_exports = {};
__export(projects_exports, {
  ProjectTier: () => ProjectTier,
  ProjectType: () => ProjectType
});
var ProjectTier = /* @__PURE__ */ ((ProjectTier2) => {
  ProjectTier2["FREE"] = "free";
  ProjectTier2["PAID"] = "paid";
  return ProjectTier2;
})(ProjectTier || {});
var ProjectType = /* @__PURE__ */ ((ProjectType2) => {
  ProjectType2["REGULAR"] = "regular";
  ProjectType2["PERSONAL"] = "personal";
  return ProjectType2;
})(ProjectType || {});

// src/rest/types/users.ts
var users_exports = {};

// src/rest/client.ts
function validateAPIAuthentication(auth) {
  return auth === "bearer" || auth === "pat" || auth === "ptk";
}
var HopAPIError = class extends Error {
  constructor(request, response, data) {
    super(data.error.message);
    this.request = request;
    this.response = response;
    this.data = data;
    this.status = response.status;
  }
  status;
};
var APIClient = class {
  static getAuthType(auth) {
    const prefix = getIdPrefix(auth);
    if (!validateAPIAuthentication(prefix)) {
      throw new Error(`Invalid authentication type: ${prefix}`);
    }
    return prefix;
  }
  options;
  authType;
  url;
  constructor(options) {
    this.options = options;
    this.authType = APIClient.getAuthType(options.authentication);
    this.url = createURLBuilder(options.baseUrl);
  }
  async get(path, query, init) {
    return this.request(
      "GET",
      path,
      void 0,
      query,
      init
    );
  }
  post(path, body, query, init) {
    return this.request("POST", path, body, query, init);
  }
  put(path, body, query, init) {
    return this.request(
      "PUT",
      path,
      body,
      query,
      init
    );
  }
  patch(path, body, query, init) {
    return this.request("PATCH", path, body, query, init);
  }
  delete(path, body, query, init) {
    return this.request("DELETE", path, body, query, init);
  }
  async raw(request) {
    request.headers.set("Authorization", this.options.authentication);
    if (!IS_BROWSER) {
      request.headers.set("User-Agent", "Hop-API-Client");
    }
    return this.parseResponse(request, await fetch(request));
  }
  async parseResponse(request, response) {
    if (response.status === 204 || !response.headers.get("Content-Type")?.includes("application/json")) {
      return void 0;
    }
    const result = await response.json().catch(
      (error) => {
        return {
          success: false,
          error: {
            code: "local_client_error",
            message: error.message
          }
        };
      }
    );
    if (!result.success) {
      throw new HopAPIError(request, response, result);
    }
    return result.data;
  }
  async request(method, path, body, query = {}, init = {}) {
    const url = this.url(path, query);
    const headers = new Headers2({
      ...init?.headers ?? {},
      Authorization: this.options.authentication
    });
    if (!IS_BROWSER) {
      headers.set("User-Agent", "Hop-API-Client");
    }
    if (body !== void 0) {
      if (method === "GET") {
        throw new Error("Cannot send a GET request with a body");
      }
      headers.set("Content-Type", "application/json");
    }
    const request = new Request2(url, {
      method,
      body: body ? JSON.stringify(body) : void 0,
      headers,
      ...init
    });
    return this.parseResponse(request, await fetch(request));
  }
};

// src/sdks/channels.ts
import { create } from "@onehop/json-methods";

// src/sdks/create.ts
function sdk(builder) {
  return builder;
}

// src/sdks/channels.ts
var channels = sdk((client) => {
  const Channels = create().methods({
    async setState(state) {
      await updateState(this.id, state, "set");
    },
    async patchState(state) {
      await updateState(this.id, state, "patch");
    },
    async subscribeToken(token) {
      await channelsSDK.subscribeToken(this.id, token);
    },
    async subscribeTokens(tokens) {
      await channelsSDK.subscribeTokens(this.id, tokens);
    },
    async publishMessage(name, data) {
      await channelsSDK.publishMessage(this.id, name, data);
    }
  });
  async function updateState(channelId, newState, mode) {
    let state;
    if (typeof newState === "function") {
      const { state: oldState } = await client.get(
        "/v1/channels/:channel_id/state",
        { channel_id: channelId }
      );
      state = await newState(oldState);
    } else {
      state = newState;
    }
    if (mode === "patch") {
      await client.patch("/v1/channels/:channel_id/state", state, {
        channel_id: channelId
      });
    } else {
      await client.put("/v1/channels/:channel_id/state", state, {
        channel_id: channelId
      });
    }
  }
  const channelsSDK = {
    async create(type, id2, options, project) {
      if (!project && client.authType !== "ptk") {
        throw new Error(
          "Project must be provided when creating a channel with bearer or PAT auth"
        );
      }
      const { channel } = id2 ? await client.put(
        "/v1/channels/:channel_id",
        { type, state: options?.state ?? {} },
        { project, channel_id: id2 }
      ) : await client.post(
        "/v1/channels",
        { type, state: options?.state ?? {} },
        { project }
      );
      return Channels.from(channel);
    },
    async get(id2) {
      const { channel } = await client.get("/v1/channels/:channel_id", {
        channel_id: id2
      });
      return Channels.from(channel);
    },
    async getAll(project) {
      const { channels: channels2 } = await client.get("/v1/channels", { project });
      return channels2.map(Channels.from);
    },
    async subscribeToken(channel, token) {
      const id2 = typeof channel === "object" ? channel.id : channel;
      await client.put(
        "/v1/channels/:channel_id/subscribers/:token",
        void 0,
        { channel_id: id2, token }
      );
    },
    async subscribeTokens(channel, tokens) {
      const promises = [];
      for (const subscription of tokens) {
        promises.push(this.subscribeToken(channel, subscription));
      }
      await Promise.allSettled(promises);
    },
    async getAllTokens(channel) {
      const id2 = typeof channel === "object" ? channel.id : channel;
      const { tokens } = await client.get("/v1/channels/:channel_id/tokens", {
        channel_id: id2
      });
      return tokens;
    },
    async setState(channel, state) {
      const id2 = typeof channel === "object" ? channel.id : channel;
      return updateState(id2, state, "set");
    },
    async patchState(channel, state) {
      const id2 = typeof channel === "object" ? channel.id : channel;
      return updateState(id2, state, "patch");
    },
    async publishMessage(channel, event, data) {
      const id2 = typeof channel === "object" ? channel.id : channel;
      await client.post(
        "/v1/channels/:channel_id/messages",
        { e: event, d: data },
        { channel_id: id2 }
      );
    },
    async delete(id2) {
      await client.delete("/v1/channels/:channel_id", void 0, {
        channel_id: id2
      });
    },
    async getStats(id2) {
      const { stats } = await client.get("/v1/channels/:channel_id/stats", {
        channel_id: id2
      });
      return stats;
    },
    tokens: {
      async delete(token) {
        await client.delete("/v1/channels/tokens/:token", void 0, {
          token
        });
      },
      async create(state = {}, project) {
        if (!project && client.authType !== "ptk") {
          throw new Error(
            "Project must be provided when creating a channel token with bearer or PAT auth"
          );
        }
        const { token } = await client.post(
          "/v1/channels/tokens",
          { state },
          { project }
        );
        return token;
      },
      async setState(id2, state) {
        const { token } = await client.patch(
          "/v1/channels/tokens/:token",
          { state },
          { token: id2 }
        );
        return token;
      },
      async get(id2) {
        const { token } = await client.get("/v1/channels/tokens/:token", {
          token: id2
        });
        return token;
      },
      async isOnline(idOrToken) {
        if (typeof idOrToken === "object") {
          return idOrToken.is_online;
        }
        const { token } = await client.get("/v1/channels/tokens/:token", {
          token: idOrToken
        });
        return token.is_online;
      },
      async publishDirectMessage(token, event, data) {
        await client.post(
          "/v1/channels/tokens/:token/messages",
          { e: event, d: data },
          { token }
        );
      }
    }
  };
  return channelsSDK;
});

// src/sdks/ignite.ts
import { create as create2 } from "@onehop/json-methods";

// src/util/size.ts
var units = ["gb", "mb", "kb", "b"];
function isValidByteString(value) {
  return units.some((unit) => {
    if (!value.endsWith(unit)) {
      return false;
    }
    return !isNaN(parseFloat(value.slice(0, -unit.length)));
  });
}
function parseSize(size) {
  size = size.toLowerCase();
  const unit = units.find((u) => size.endsWith(u));
  if (!unit) {
    throw new Error(`Invalid size: ${size}`);
  }
  const num = parseFloat(size.slice(0, -unit.length));
  if (isNaN(num)) {
    throw new Error(`Invalid size: ${size}`);
  }
  switch (unit.toLowerCase()) {
    case "gb":
      return num * 1024 * 1024 * 1024;
    case "mb":
      return num * 1024 * 1024;
    case "kb":
      return num * 1024;
    case "b":
    default:
      return num;
  }
}

// src/sdks/ignite.ts
var SIX_MB_IN_BYTES = 6 * 1024 * 1024;
var ignite = sdk((client) => {
  const Gateways = create2().methods({
    async addDomain(domain) {
      await client.post(
        "/v1/ignite/gateways/:gateway_id/domains",
        { domain },
        { gateway_id: this.id }
      );
    }
  });
  const Deployments = create2().methods({
    getContainers() {
      return igniteSDK.deployments.getContainers(this.id);
    },
    delete() {
      return igniteSDK.deployments.delete(this.id);
    },
    createContainer() {
      return igniteSDK.containers.create(this.id);
    },
    createGateway(type, protocol, port) {
      return igniteSDK.deployments.gateways.create(
        this.id,
        type,
        protocol,
        port
      );
    }
  });
  async function createDeployment(configOrProject, bearerOrPatConfig) {
    let config;
    let project = void 0;
    if (typeof configOrProject === "object") {
      if (client.authType === "ptk") {
        config = configOrProject;
      } else {
        throw new Error(
          "First argument must be the project ID when using bearer authentication to create deployments."
        );
      }
    } else {
      if (!bearerOrPatConfig) {
        throw new Error(
          "Second argument must be the deployment config when using bearer authentication to create deployments."
        );
      }
      if (client.authType === "bearer" || client.authType === "pat") {
        project = configOrProject;
        config = bearerOrPatConfig;
      } else {
        throw new Error(
          "Only argument must be the config when using secret authentication to create deployments."
        );
      }
    }
    if (parseSize(config.resources.ram) <= SIX_MB_IN_BYTES) {
      throw new Error(
        "Allocated memory must be greater than 6MB when creating a deployment."
      );
    }
    const { deployment } = await client.post("/v1/ignite/deployments", config, {
      project
    });
    return Deployments.from(deployment);
  }
  async function updateContainerState(container, state) {
    await client.put(
      "/v1/ignite/containers/:container_id/state",
      { preferred_state: state },
      { container_id: container }
    );
  }
  async function getDeployment(projectIdOrId, name) {
    if (name) {
      assertId(
        projectIdOrId,
        "project",
        "You must provide a project ID to get a deployment by name"
      );
      const { deployment: deployment2 } = await client.get("/v1/ignite/deployments/search", {
        name,
        project: projectIdOrId
      });
      return Deployments.from(deployment2);
    }
    assertId(
      projectIdOrId,
      "deployment",
      "You must provide a valid deployment ID."
    );
    const { deployment } = await client.get(
      "/v1/ignite/deployments/:deployment_id",
      { deployment_id: projectIdOrId }
    );
    return Deployments.from(deployment);
  }
  const igniteSDK = {
    gateways: {
      async addDomain(gatewayId, domain) {
        await client.post(
          "/v1/ignite/gateways/:gateway_id/domains",
          { domain },
          { gateway_id: gatewayId }
        );
      },
      async get(gatewayId) {
        const { gateway } = await client.get("/v1/ignite/gateways/:gateway_id", {
          gateway_id: gatewayId
        });
        return gateway;
      }
    },
    deployments: {
      create: createDeployment,
      get: getDeployment,
      async getContainers(deployment) {
        const { containers } = await client.get(
          "/v1/ignite/deployments/:deployment_id/containers",
          { deployment_id: deployment }
        );
        return containers;
      },
      async getAll(projectId) {
        if (client.authType !== "ptk" && !projectId) {
          throw new Error(
            "Project ID is required for Bearer or PAT authentication"
          );
        }
        if (client.authType === "ptk" && projectId) {
          throw new Error(
            "Project ID is not required for secret authentication"
          );
        }
        const { deployments } = await client.get(
          "/v1/ignite/deployments",
          projectId ? { project: projectId } : {}
        );
        return deployments.map(Deployments.from);
      },
      async delete(deployment) {
        await client.delete(
          "/v1/ignite/deployments/:deployment_id",
          void 0,
          { deployment_id: deployment }
        );
      },
      gateways: {
        async getAll(deploymentId) {
          const { gateways } = await client.get(
            "/v1/ignite/deployments/:deployment_id/gateways",
            { deployment_id: deploymentId }
          );
          return gateways.map(Gateways.from);
        },
        async create(deployment, type, protocol, listeningPort) {
          const deploymentId = typeof deployment === "object" ? deployment.id : deployment;
          const { gateway } = await client.post(
            "/v1/ignite/deployments/:deployment_id/gateways",
            { type, protocol, listening_port: listeningPort },
            { deployment_id: deploymentId }
          );
          return Gateways.from(gateway);
        }
      }
    },
    containers: {
      async delete(container) {
        await client.delete("/v1/ignite/containers/:container_id", void 0, {
          container_id: container
        });
      },
      async getLogs(container, options = {}) {
        const { logs } = await client.get(
          "/v1/ignite/containers/:container_id/logs",
          { container_id: container, ...options }
        );
        return logs;
      },
      async stop(container) {
        await updateContainerState(
          container,
          api_exports.Ignite.ContainerState.STOPPED
        );
      },
      async start(container) {
        await updateContainerState(
          container,
          api_exports.Ignite.ContainerState.RUNNING
        );
      },
      async create(deployment) {
        const { container } = await client.post(
          "/v1/ignite/deployments/:deployment_id/containers",
          void 0,
          { deployment_id: deployment }
        );
        return container;
      }
    }
  };
  return igniteSDK;
});

// src/sdks/pipe.ts
import { create as create3 } from "@onehop/json-methods";
var pipe = sdk((client) => {
  const Rooms = create3().methods({
    async delete() {
      await pipeSDK.rooms.delete(this.id);
    }
  });
  const pipeSDK = {
    rooms: {
      async getAll(project) {
        if (!project && client.authType !== "ptk") {
          throw new Error(
            "You must provide ID project id when using a bearer or pat token."
          );
        }
        const { rooms } = await client.get("/v1/pipe/rooms", { project });
        return rooms.map(Rooms.from);
      },
      async create(name, options) {
        const { room } = await client.post(
          "/v1/pipe/rooms",
          {
            name,
            ingest_protocol: options.ingestProtocol,
            region: "us-east-1" /* US_EAST_1 */,
            ephemeral: options.ephemeral ?? false,
            delivery_protocols: options.deliveryProtocols,
            llhls_config: options.hlsConfig
          },
          {}
        );
        return Rooms.from(room);
      },
      async delete(room) {
        await client.delete("/v1/pipe/rooms/:room_id", void 0, {
          room_id: room
        });
      }
    }
  };
  return pipeSDK;
});

// src/sdks/projects.ts
var projects = sdk((client) => {
  return {
    async getAllMembers(projectId) {
      if (client.authType !== "ptk" && !projectId) {
        throw new Error(
          "Project ID is required for bearer or PAT authentication to fetch all project members"
        );
      }
      if (projectId) {
        const { members: members2 } = await client.get("/v1/projects/:project_id/members", {
          project_id: projectId
        });
        return members2;
      }
      const { members } = await client.get("/v1/projects/@this/members", {});
      return members;
    },
    async getCurrentMember(projectId) {
      if (client.authType === "ptk") {
        throw new Error(
          "You cannot resolve a member from a project token! You must use a bearer or pat token"
        );
      }
      const { project_member: member } = await client.get(
        "/v1/projects/:project_id/members/@me",
        { project_id: projectId }
      );
      return member;
    },
    projectTokens: {
      async delete(projectTokenId, project) {
        if (client.authType !== "ptk" && !project) {
          throw new Error(
            "Project ID is required for bearer or PAT authentication to delete a project token"
          );
        }
        await client.delete(
          project ? "/v1/projects/:project_id/tokens/:project_token_id" : "/v1/projects/@this/tokens/:project_token_id",
          void 0,
          project ? { project_id: project, project_token_id: projectTokenId } : { project_token_id: projectTokenId }
        );
      },
      async get(projectId) {
        if (client.authType !== "ptk" && !projectId) {
          throw new Error(
            "Project ID is required for bearer or PAT authentication"
          );
        }
        if (!projectId) {
          const { project_tokens: keys2 } = await client.get(
            "/v1/projects/@this/tokens",
            {}
          );
          return keys2;
        }
        const { project_tokens: keys } = await client.get(
          "/v1/projects/:project_id/tokens",
          { project_id: projectId }
        );
        return keys;
      },
      async create(flags, projectId) {
        if (!projectId && client.authType !== "ptk") {
          throw new Error(
            "Project ID is required for bearer or PAT authentication to create a project token"
          );
        }
        if (!projectId) {
          const { project_token: token2 } = await client.post(
            "/v1/projects/@this/tokens",
            { flags },
            {}
          );
          return token2;
        }
        const { project_token: token } = await client.post(
          "/v1/projects/:project_id/tokens",
          { flags },
          { project_id: projectId }
        );
        return token;
      }
    },
    secrets: {
      async getAll(projectId) {
        if (client.authType !== "ptk" && !projectId) {
          throw new Error(
            "Project ID is required for bearer or PAT authentication to fetch all secrets"
          );
        }
        if (!projectId) {
          const { secrets: secrets2 } = await client.get("/v1/projects/@this/secrets", {});
          return secrets2;
        }
        const { secrets } = await client.get("/v1/projects/:project_id/secrets", {
          project_id: projectId
        });
        return secrets;
      },
      async create(name, value, projectId) {
        if (client.authType !== "ptk" && !projectId) {
          throw new Error(
            "Project ID is required for bearer or PAT authentication to create a secret"
          );
        }
        const url = client.url("/v1/projects/@this/secrets/:name", {
          name,
          project: projectId
        });
        const request = new Request2(url, {
          headers: {
            "Content-Type": "text/plain"
          },
          body: value,
          method: "PUT"
        });
        const { secret } = await client.raw(request);
        return secret;
      },
      async delete(id2, projectId) {
        if (client.authType !== "ptk" && !projectId) {
          throw new Error(
            "Project ID is required for bearer or PAT authentication to delete a secret"
          );
        }
        if (!projectId) {
          await client.delete(
            "/v1/projects/@this/secrets/:secret_id",
            void 0,
            {
              secret_id: id2
            }
          );
          return;
        }
        await client.delete(
          "/v1/projects/:project_id/secrets/:secret_id",
          void 0,
          { secret_id: id2, project_id: projectId }
        );
      }
    }
  };
});

// src/sdks/registry.ts
var registry = sdk((client) => {
  return {
    images: {
      async getAll(project) {
        if (!project && client.authType !== "ptk") {
          throw new Error("Project is required when using a PAT or bearer");
        }
        const { images } = await client.get("/v1/registry/images", {
          project
        });
        return images;
      },
      async getManifest(image) {
        const { manifests } = await client.get(
          "/v1/registry/images/:image/manifests",
          { image }
        );
        return manifests;
      },
      async delete(image) {
        await client.delete("/v1/registry/images/:image", void 0, { image });
      }
    }
  };
});

// src/sdks/users.ts
var users = sdk((client) => ({
  me: {
    async get() {
      if (client.authType === "ptk") {
        throw new Error(
          "You cannot resolve a user from a project token! You must use a Bearer or PAT."
        );
      }
      const me = await client.get("/v1/users/@me", {});
      return me;
    },
    pats: {
      async create(name) {
        if (client.authType === "ptk") {
          throw new Error(
            "You cannot create a PAT from a project token! You must use a Bearer or PAT."
          );
        }
        const { pat } = await client.post("/v1/users/@me/pats", { name }, {});
        return pat;
      },
      async getAll() {
        if (client.authType === "ptk") {
          throw new Error(
            "You cannot get all PATs from a project token! You must use a Bearer or PAT."
          );
        }
        const { pats } = await client.get("/v1/users/@me/pats", {});
        return pats;
      },
      async delete(id2) {
        if (client.authType === "ptk") {
          throw new Error(
            "You cannot delete a PAT from a project token! You must use a Bearer or PAT."
          );
        }
        await client.delete(`/v1/users/@me/pats/:pat_id`, void 0, {
          pat_id: id2
        });
      }
    }
  }
}));

// src/hop.ts
var Hop = class {
  client;
  ignite;
  users;
  projects;
  pipe;
  registry;
  channels;
  constructor(authenticationOrOptions, baseUrl = DEFAULT_BASE_URL) {
    if (!authenticationOrOptions || typeof authenticationOrOptions === "object" && !authenticationOrOptions.authentication) {
      throw new Error(
        "Missing authentication token to `new Hop()` \u2014 please provide a valid Project Token, User Bearer or Personal Access Token"
      );
    }
    this.client = new APIClient(
      typeof authenticationOrOptions === "object" ? { baseUrl: DEFAULT_BASE_URL, ...authenticationOrOptions } : { authentication: authenticationOrOptions, baseUrl }
    );
    this.ignite = ignite(this.client);
    this.users = users(this.client);
    this.projects = projects(this.client);
    this.pipe = pipe(this.client);
    this.registry = registry(this.client);
    this.channels = channels(this.client);
  }
};

// src/permissions.ts
var PROJECT_PERMISSION = /* @__PURE__ */ ((PROJECT_PERMISSION2) => {
  PROJECT_PERMISSION2["ADD_MEMBER"] = "add_member";
  PROJECT_PERMISSION2["REMOVE_MEMBER"] = "remove_member";
  PROJECT_PERMISSION2["GET_PROJECT_MEMBERS"] = "get_project_members";
  PROJECT_PERMISSION2["DELETE_PROJECT"] = "delete_project";
  PROJECT_PERMISSION2["DELETE_DEPLOYMENT"] = "delete_deployment";
  PROJECT_PERMISSION2["DELETE_CONTAINER"] = "delete_container";
  PROJECT_PERMISSION2["UPDATE_CONTAINER_STATE"] = "update_container_state";
  PROJECT_PERMISSION2["READ_DEPLOYMENTS"] = "read_deployments";
  PROJECT_PERMISSION2["CREATE_DEPLOYMENT"] = "create_deployment";
  PROJECT_PERMISSION2["CREATE_CONTAINER"] = "create_container";
  PROJECT_PERMISSION2["UPDATE_CONTAINER_CONFIG"] = "update_container_config";
  PROJECT_PERMISSION2["CREATE_ROOM"] = "create_room";
  PROJECT_PERMISSION2["READ_ROOM"] = "read_room";
  PROJECT_PERMISSION2["DELETE_ROOM"] = "delete_room";
  PROJECT_PERMISSION2["CREATE_ROOM_PRODUCER"] = "create_room_producer";
  PROJECT_PERMISSION2["CREATE_PROJECT_TOKEN"] = "create_project_token";
  PROJECT_PERMISSION2["DELETE_PROJECT_TOKEN"] = "delete_project_token";
  PROJECT_PERMISSION2["READ_PROJECT_TOKENS"] = "read_project_tokens";
  PROJECT_PERMISSION2["READ_CONTAINER_LOGS"] = "read_container_logs";
  PROJECT_PERMISSION2["CREATE_PROJECT_SECRET"] = "create_project_secret";
  PROJECT_PERMISSION2["READ_PROJECT_SECRETS"] = "read_project_secrets";
  PROJECT_PERMISSION2["DELETE_PROJECT_SECRET"] = "delete_project_secret";
  PROJECT_PERMISSION2["GET_REGISTRY_IMAGES"] = "get_registry_images";
  PROJECT_PERMISSION2["CREATE_CHANNEL"] = "create_channel";
  PROJECT_PERMISSION2["CREATE_CHANNEL_TOKEN"] = "create_channel_token";
  PROJECT_PERMISSION2["CREATE_LEAP_TOKEN"] = "create_leap_token";
  PROJECT_PERMISSION2["CREATE_GATEWAY"] = "create_gateway";
  PROJECT_PERMISSION2["ADD_DOMAIN"] = "add_domain";
  PROJECT_PERMISSION2["DELETE_CHANNELS"] = "delete_channels";
  PROJECT_PERMISSION2["UPDATE_CHANNEL_STATE"] = "update_channel_state";
  PROJECT_PERMISSION2["PUBLISH_CHANNEL_MESSAGES"] = "publish_channel_messages";
  PROJECT_PERMISSION2["READ_CHANNELS"] = "read_channels";
  PROJECT_PERMISSION2["READ_LEAP_TOKENS"] = "read_leap_tokens";
  PROJECT_PERMISSION2["MANAGE_CHANNEL_SUBSCRIBERS"] = "manage_channel_subscribers";
  PROJECT_PERMISSION2["UPDATE_LEAP_TOKEN"] = "update_leap_token";
  PROJECT_PERMISSION2["DELETE_DOMAIN"] = "delete_domain";
  PROJECT_PERMISSION2["DELETE_GATEWAY"] = "delete_gateway";
  PROJECT_PERMISSION2["GET_INTERNAL_DOMAIN"] = "get_internal_domain";
  PROJECT_PERMISSION2["MESSAGE_TOKEN"] = "message_token";
  PROJECT_PERMISSION2["ROLLOUT"] = "rollout";
  PROJECT_PERMISSION2["REQUEST_QUOTA_INCREASE"] = "request_quota_increase";
  PROJECT_PERMISSION2["READ_BILLING"] = "read_billing";
  PROJECT_PERMISSION2["READ_GATEWAYS"] = "read_gateways";
  PROJECT_PERMISSION2["DELETE_REGISTRY_IMAGES"] = "delete_registry_images";
  return PROJECT_PERMISSION2;
})(PROJECT_PERMISSION || {});
var permissionsMap = {
  ["add_member" /* ADD_MEMBER */]: 1n << 0n,
  ["remove_member" /* REMOVE_MEMBER */]: 1n << 1n,
  ["get_project_members" /* GET_PROJECT_MEMBERS */]: 1n << 2n,
  ["delete_project" /* DELETE_PROJECT */]: 1n << 3n,
  ["delete_deployment" /* DELETE_DEPLOYMENT */]: 1n << 4n,
  ["delete_container" /* DELETE_CONTAINER */]: 1n << 5n,
  ["update_container_state" /* UPDATE_CONTAINER_STATE */]: 1n << 6n,
  ["read_deployments" /* READ_DEPLOYMENTS */]: 1n << 7n,
  ["create_deployment" /* CREATE_DEPLOYMENT */]: 1n << 8n,
  ["create_container" /* CREATE_CONTAINER */]: 1n << 9n,
  ["update_container_config" /* UPDATE_CONTAINER_CONFIG */]: 1n << 10n,
  ["create_room" /* CREATE_ROOM */]: 1n << 11n,
  ["read_room" /* READ_ROOM */]: 1n << 12n,
  ["delete_room" /* DELETE_ROOM */]: 1n << 13n,
  ["create_room_producer" /* CREATE_ROOM_PRODUCER */]: 1n << 14n,
  ["create_project_token" /* CREATE_PROJECT_TOKEN */]: 1n << 15n,
  ["delete_project_token" /* DELETE_PROJECT_TOKEN */]: 1n << 16n,
  ["read_project_tokens" /* READ_PROJECT_TOKENS */]: 1n << 17n,
  ["read_container_logs" /* READ_CONTAINER_LOGS */]: 1n << 18n,
  ["create_project_secret" /* CREATE_PROJECT_SECRET */]: 1n << 19n,
  ["read_project_secrets" /* READ_PROJECT_SECRETS */]: 1n << 20n,
  ["delete_project_secret" /* DELETE_PROJECT_SECRET */]: 1n << 21n,
  ["get_registry_images" /* GET_REGISTRY_IMAGES */]: 1n << 22n,
  ["create_channel_token" /* CREATE_CHANNEL_TOKEN */]: 1n << 24n,
  ["create_gateway" /* CREATE_GATEWAY */]: 1n << 25n,
  ["add_domain" /* ADD_DOMAIN */]: 1n << 26n,
  ["delete_channels" /* DELETE_CHANNELS */]: 1n << 27n,
  ["update_channel_state" /* UPDATE_CHANNEL_STATE */]: 1n << 28n,
  ["read_channels" /* READ_CHANNELS */]: 1n << 29n,
  ["publish_channel_messages" /* PUBLISH_CHANNEL_MESSAGES */]: 1n << 30n,
  ["manage_channel_subscribers" /* MANAGE_CHANNEL_SUBSCRIBERS */]: 1n << 31n,
  ["delete_domain" /* DELETE_DOMAIN */]: 1n << 32n,
  ["delete_gateway" /* DELETE_GATEWAY */]: 1n << 33n,
  ["get_internal_domain" /* GET_INTERNAL_DOMAIN */]: 1n << 34n,
  ["create_leap_token" /* CREATE_LEAP_TOKEN */]: 1n << 35n,
  ["read_leap_tokens" /* READ_LEAP_TOKENS */]: 1n << 36n,
  ["update_leap_token" /* UPDATE_LEAP_TOKEN */]: 1n << 37n,
  ["message_token" /* MESSAGE_TOKEN */]: 1n << 38n,
  ["create_channel" /* CREATE_CHANNEL */]: 1n << 39n,
  ["rollout" /* ROLLOUT */]: 1n << 40n,
  ["request_quota_increase" /* REQUEST_QUOTA_INCREASE */]: 1n << 41n,
  ["read_billing" /* READ_BILLING */]: 1n << 42n,
  ["read_gateways" /* READ_GATEWAYS */]: 1n << 43n,
  ["delete_registry_images" /* DELETE_REGISTRY_IMAGES */]: 1n << 44n
};
var BROAD_PERMISSIONS_MAP = {
  MANAGE_MEMBERS: permissionsMap.add_member | permissionsMap.remove_member | permissionsMap.get_project_members,
  MANAGE_PROJECT_TOKENS: permissionsMap.create_project_token | permissionsMap.delete_project_token | permissionsMap.read_project_tokens,
  MANAGE_DEPLOYMENTS: permissionsMap.create_container | permissionsMap.delete_container | permissionsMap.update_container_state | permissionsMap.read_container_logs | permissionsMap.update_container_config | permissionsMap.add_domain | permissionsMap.delete_domain | permissionsMap.create_deployment | permissionsMap.delete_deployment | permissionsMap.read_deployments | permissionsMap.rollout | permissionsMap.delete_gateway | permissionsMap.get_internal_domain,
  MANAGE_PIPE: permissionsMap.create_room | permissionsMap.delete_room | permissionsMap.read_room,
  MANAGE_SECRETS: permissionsMap.create_project_secret | permissionsMap.delete_project_secret | permissionsMap.read_project_secrets,
  MANAGE_CHANNELS: permissionsMap.create_leap_token | permissionsMap.create_channel_token | permissionsMap.create_gateway | permissionsMap.read_leap_tokens | permissionsMap.update_leap_token | permissionsMap.create_channel | permissionsMap.delete_channels | permissionsMap.update_channel_state | permissionsMap.read_channels | permissionsMap.publish_channel_messages | permissionsMap.manage_channel_subscribers | permissionsMap.message_token,
  MANAGE_REGISTRY: permissionsMap.get_registry_images | permissionsMap.delete_registry_images,
  READ_ONLY: permissionsMap.read_deployments | permissionsMap.read_container_logs | permissionsMap.read_room | permissionsMap.read_channels | permissionsMap.read_project_tokens | permissionsMap.read_project_secrets | permissionsMap.read_leap_tokens | permissionsMap.get_project_members | permissionsMap.read_gateways,
  MANAGE_QUOTAS: permissionsMap.request_quota_increase,
  MANAGE_ROLLOUTS: permissionsMap.rollout,
  MANAGE_BILLING: permissionsMap.read_billing
};
var roles = {
  viewer: BROAD_PERMISSIONS_MAP.READ_ONLY,
  editor: BROAD_PERMISSIONS_MAP.MANAGE_CHANNELS | BROAD_PERMISSIONS_MAP.MANAGE_DEPLOYMENTS | BROAD_PERMISSIONS_MAP.MANAGE_PIPE | BROAD_PERMISSIONS_MAP.MANAGE_SECRETS | BROAD_PERMISSIONS_MAP.MANAGE_REGISTRY | BROAD_PERMISSIONS_MAP.READ_ONLY,
  admin: BROAD_PERMISSIONS_MAP.MANAGE_CHANNELS | BROAD_PERMISSIONS_MAP.MANAGE_DEPLOYMENTS | BROAD_PERMISSIONS_MAP.MANAGE_MEMBERS | BROAD_PERMISSIONS_MAP.MANAGE_PIPE | BROAD_PERMISSIONS_MAP.MANAGE_PROJECT_TOKENS | BROAD_PERMISSIONS_MAP.MANAGE_SECRETS | BROAD_PERMISSIONS_MAP.MANAGE_REGISTRY | BROAD_PERMISSIONS_MAP.MANAGE_QUOTAS | BROAD_PERMISSIONS_MAP.READ_ONLY,
  owner: BROAD_PERMISSIONS_MAP.MANAGE_CHANNELS | BROAD_PERMISSIONS_MAP.MANAGE_DEPLOYMENTS | BROAD_PERMISSIONS_MAP.MANAGE_MEMBERS | BROAD_PERMISSIONS_MAP.MANAGE_PIPE | BROAD_PERMISSIONS_MAP.MANAGE_PROJECT_TOKENS | BROAD_PERMISSIONS_MAP.MANAGE_SECRETS | BROAD_PERMISSIONS_MAP.MANAGE_REGISTRY | BROAD_PERMISSIONS_MAP.MANAGE_QUOTAS | BROAD_PERMISSIONS_MAP.MANAGE_ROLLOUTS | BROAD_PERMISSIONS_MAP.MANAGE_BILLING
};
var permissions = {
  add(value, flag) {
    return BigInt(value) | BigInt(flag);
  },
  test(value, flag) {
    return Boolean(BigInt(value) & BigInt(flag));
  },
  subtract(value, flag) {
    return BigInt(value) & ~BigInt(flag);
  }
};
export {
  api_exports as API,
  APIClient,
  BROAD_PERMISSIONS_MAP,
  ChannelType,
  ContainerState,
  DEFAULT_BASE_URL,
  Hop,
  HopAPIError,
  ID_PREFIXES,
  IS_BROWSER,
  PROJECT_PERMISSION,
  RuntimeType,
  asId,
  assertId,
  getIdPrefix,
  id,
  isValidByteString,
  parseSize,
  permissions,
  permissionsMap,
  roles,
  units,
  validateAPIAuthentication,
  validateId,
  validateIdPrefix
};
//# sourceMappingURL=index.js.map